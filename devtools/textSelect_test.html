<!DOCTYPE html>
<html>
<head>
    <title>Text Select</title>
    <script type="text/javascript" src="select.js"></script>
    <style type="text/css">
        * { margin: 0; padding: 0;}
        body {
            background: url("../PSD/960grid.png");
        }    
        .p1 {
            position: absolute;
            left: 100px;
            top: 30px;

            padding: 50px;

            width: 500px;
            height: 200px;
            text-indent: 40px;
        }
        span {
            color: blue;
        }
        em {
            background: yellow;
        }
    </style>
</head>
<body>
    <p class="p1">Empty border-boxes are completely ignored. If all the element's border-boxes are empty, then a rectangle is returned with a width and height of zero and where the top and l <span>eft are the top-left of the border-box for the first CSS box (in content order) for the element.</span> <br><br>The amount of scrolling that has been done of the viewport area <span>(or any other scrollable element)</span> is taken into account when computing the bounding rectangle. This means that the top and left property change their values as soon as the scrolling position changes (so their values are relative to the viewport and not absolute). If this is not the desired behaviour just add the current scrolling position to the top and left property (via window.scrollX and window.scrollY) to get constant values independent from the current scrolling position.</p>
</body>
<script type="text/javascript">

    document.addEventListener("mouseup", function () {
        var selection = Select.getSelection();
        var range = selection.range;
        window.arr = [];
        if (range) {
            arr.push(range);
            var ancestorContainer = range.commonAncestorContainer;
            // var walker = document.createTreeWalker(ancestorContainer, NodeFilter.SHOW_TEXT, null, false);
            // var node;
            // var textNodes = [];

            // console.log(ancestorContainer);
            // while(node = walker.nextNode()) {
            //     textNodes.push({
            //         node: node,
            //         value: node.nodeValue
            //     });
            // }            

            // console.log(textNodes);

            var content = range.cloneContents();
            var childNodes = content.childNodes;
            // for (var i = 0; i < childNodes.length; i++) {
            //     for (var j = 0; j < textNodes.length; j++) {
            //         if (textNodes[j].value.indexOf(childNodes[i].textContent) > -1) {
            //             var range = document.createRange();
            //             console.log(textNodes[j]);
            //             range.selectNode(textNodes[j]);
            //             var surNode = document.createElement("em");
            //             surNode.style.backgroundColor = "yellow";
            //             range.surroundContents(surNode);
            //         }
            //     }
            //     console.log(childNodes[i], childNodes[i].textContent, childNodes[i].nodeType);
            // }
            
            document.designMode = "on";
            var change = document.execCommand("backColor", false, "yellow");
            document.designMode = "off";

            // window.clearSelection = function () {
            //     arr.forEach(function (sel) {
            //         sel.removeAllRanges();
            //     })          
            // }
            selection.selection.removeAllRanges();
        }
    })
</script>
</html>