<!DOCTYPE html>
<html>
<head>
    <title>Command Menu</title>
    <link rel="stylesheet" type="text/css" href="../css/demo/basic.css">
    <link rel="stylesheet" type="text/css" href="../css/demo/theme.css">
    <link rel="stylesheet" type="text/css" href="../css/demo/transform.css">
    <script type="text/javascript" src="../js/lib/lib.js"></script>
</head>
<body class="theme-white">
    <div id="article">
There is a lot of duplication due to vendor prefixes - until the specification if finalised, this will persist. If this bothers you, there are various tools such as CSS Scaffold, LESS, or my preference - SASS, that allow you to define mixins to avoid repetitive code.

Another approach is simply to write the CSS without the prefixes, then use Lea Verou's -prefix-free to add them in at runtime.

Something you definitely shouldn't do is to only include the webkit prefix. Tempting though it seems, particularly when developing for mobile devices, webkit isn't the only rendering engine!

It's worth noting as well that there isn't an -ms- prefix on these properties. IE10 was the first browser to ship without a prefix on these. The betas of IE10 did use the prefix however, so you may see code using -ms-. It's not needed though.

The syntax is pretty straightforward, you specify the property you want to animate, all or border-radius or color or whatever, the time to run, then the transition timing function. The options for the timing function are shown below.

Whenever any property changes, then it will animate instead of changing directly. This can be due to a different set of properties set on a pseudo class such as hover, or a new class or properties set by javascript. The example below uses :hover to change the properties – no javascript is needed.

To see the difference in speed, have a look at the speed test.
There is a lot of duplication due to vendor prefixes - until the specification if finalised, this will persist. If this bothers you, there are various tools such as CSS Scaffold, LESS, or my preference - SASS, that allow you to define mixins to avoid repetitive code.

Another approach is simply to write the CSS without the prefixes, then use Lea Verou's -prefix-free to add them in at runtime.

Something you definitely shouldn't do is to only include the webkit prefix. Tempting though it seems, particularly when developing for mobile devices, webkit isn't the only rendering engine!

It's worth noting as well that there isn't an -ms- prefix on these properties. IE10 was the first browser to ship without a prefix on these. The betas of IE10 did use the prefix however, so you may see code using -ms-. It's not needed though.

The syntax is pretty straightforward, you specify the property you want to animate, all or border-radius or color or whatever, the time to run, then the transition timing function. The options for the timing function are shown below.

Whenever any property changes, then it will animate instead of changing directly. This can be due to a different set of properties set on a pseudo class such as hover, or a new class or properties set by javascript. The example below uses :hover to change the properties – no javascript is needed.

To see the difference in speed, have a look at the speed test.
There is a lot of duplication due to vendor prefixes - until the specification if finalised, this will persist. If this bothers you, there are various tools such as CSS Scaffold, LESS, or my preference - SASS, that allow you to define mixins to avoid repetitive code.

Another approach is simply to write the CSS without the prefixes, then use Lea Verou's -prefix-free to add them in at runtime.

Something you definitely shouldn't do is to only include the webkit prefix. Tempting though it seems, particularly when developing for mobile devices, webkit isn't the only rendering engine!

It's worth noting as well that there isn't an -ms- prefix on these properties. IE10 was the first browser to ship without a prefix on these. The betas of IE10 did use the prefix however, so you may see code using -ms-. It's not needed though.

The syntax is pretty straightforward, you specify the property you want to animate, all or border-radius or color or whatever, the time to run, then the transition timing function. The options for the timing function are shown below.

Whenever any property changes, then it will animate instead of changing directly. This can be due to a different set of properties set on a pseudo class such as hover, or a new class or properties set by javascript. The example below uses :hover to change the properties – no javascript is needed.

To see the difference in speed, have a look at the speed test.
    </div>
    <div id="chromeNote-threeDWorld" class="chromeNote-setup-3d-perspective">
        <div id="chromeNote-cmdMenu-mask" class="chromeNote-decorate-circle chromeNote-setup-3d-style chromeNote-transform-scale-point1 chromeNote-hide">
            <div id="chromeNote-cmdMenu-wrap" class="chromeNote-decorate-circle chromeNote-setup-3d-style">
                <div id="chromeNote-cmdMenu-btn" class="chromeNote-decorate-circle chromeNote-setup-3d-style chromeNote-transform-translateZ"></div>
                <ul>
                    <li class="chromeNote-cmdMenu-menuItem-outerWrap chromeNote-setup-3d-style chromeNote-transform-origin-100and100 chromeNote-transform-transition">
                        <a class="chromeNote-cmdMenu-menuItem-innerWrap chromeNote-decorate-circle" href="javascript:void(0)">
                            <span class="chromeNote-cmdMenu-menuItem-text">Menu1</span>
                        </a>
                    </li>
                    <li class="chromeNote-cmdMenu-menuItem-outerWrap chromeNote-setup-3d-style chromeNote-transform-origin-100and100 chromeNote-transform-transition">
                        <a class="chromeNote-cmdMenu-menuItem-innerWrap chromeNote-decorate-circle" href="javascript:void(0)">
                            <span class="chromeNote-cmdMenu-menuItem-text">Menu2</span>
                        </a>
                    </li>
                    <li class="chromeNote-cmdMenu-menuItem-outerWrap chromeNote-setup-3d-style chromeNote-transform-origin-100and100 chromeNote-transform-transition">
                        <a class="chromeNote-cmdMenu-menuItem-innerWrap chromeNote-decorate-circle" href="javascript:void(0)">
                            <span class="chromeNote-cmdMenu-menuItem-text">Menu3</span>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</body>
<script type="text/javascript">
    function computeAngle(elems) {
        var total = 360;
        var len = elems.length
        var eachAngle = total / len;

        for (var i = 0; i < elems.length; i++) {
            var el = elems[i];
            var innerEl = el.querySelector("a");

            /*
                eachAngle - 90: 保证最上方有一条直线
            */
            var outerRotateDeg = (i * eachAngle) - (eachAngle - 90); 
            var rotate = " rotate(" + outerRotateDeg + "deg) ";

            var outerSkewXDeg = 90 - eachAngle;
            var skewX = " skewX(" + outerSkewXDeg + "deg) ";

            el.setAttribute("data-rotate", outerRotateDeg);
            el.setAttribute("data-skewX", outerSkewXDeg);
            el.style.webkitTransform += rotate + skewX;

            var innerSkewXDeg = outerSkewXDeg * (-1);
            var innerRotateDeg = (90 - parseFloat(eachAngle) / 2) * (-1);

            rotate = " rotate(" + innerRotateDeg + "deg) ";
            skewX = " skewX(" + innerSkewXDeg + "deg) ";

            innerEl.style.webkitTransform += skewX + rotate;

            var text = innerEl.querySelector("span");

            var textRotateDeg = innerRotateDeg * (-1) - outerRotateDeg;
            var textRotate = " rotate(" + textRotateDeg + "deg) ";
            text.style.webkitTransform += textRotate;
        }
    }


    var links = document.querySelectorAll("li");
    computeAngle(links);

    for (var i = 0; i < links.length; i++) {
        var hook = links[i].querySelector("a");
        hook.addEventListener("mouseout", function (e) {
            // e.stopPropagation();
        })
    }

    var translateZ = "20";
    for (var i = 0; i < links.length; i++) {
        var link = links[i];
        link.addEventListener("mouseover", function (e) {

            // var target = e.target;
            var target = this;
            var outerRotateDeg = target.getAttribute("data-rotate");
            var rotate = " rotate(" + outerRotateDeg + "deg) ";

            var outerSkewXDeg = target.getAttribute("data-skewX");
            var skewX = " skewX(" + outerSkewXDeg + "deg) ";

            var translateZ = " translateZ(20px) ";

            target.style.webkitTransform = rotate + skewX + translateZ;
            target = $(this);
            target.addClass("hover");

        }, false);

        link.addEventListener("mouseout", function (e) {

            // var target = e.target;
            var target = this;
            var outerRotateDeg = target.getAttribute("data-rotate");
            var rotate = " rotate(" + outerRotateDeg + "deg) ";

            var outerSkewXDeg = target.getAttribute("data-skewX");
            var skewX = " skewX(" + outerSkewXDeg + "deg) ";

            var translateZ = " translateZ(0px) ";

            target.style.webkitTransform = rotate + skewX;
            target = $(this);
            target.removeClass("hover");
        }, false);
    }

    var worldXAngle, worldYAngle, backupX, backupY;
    var disableMousemove = true;
    // var disableMousemove = false;

    window.addEventListener( 'mousemove', function( e ) {
        if (disableMousemove) return false;

        var xPercent = parseFloat(353) / window.innerWidth;
        var yPercent = parseFloat(252) / window.innerHeight;

        backupX = worldXAngle, backupY = worldYAngle;

        worldYAngle = -( xPercent - ( e.clientX / window.innerWidth ) ) * 180;
        worldXAngle = ( yPercent - ( e.clientY / window.innerHeight ) ) * 180;

        if (Math.abs(worldXAngle) >= 5) worldXAngle = backupX;
        if (Math.abs(worldYAngle) >= 5) worldYAngle = backupY;

        var world = document.querySelector("#chromeNote-cmdMenu-wrap");
        var outer = document.querySelector("#chromeNote-cmdMenu-mask");

        world.style.webkitTransform = 'translateZ(0px ) \
        rotateX( ' + worldXAngle * (-1) + 'deg) \
        rotateY( ' + worldYAngle * (-1) + 'deg)';

        outer.style.webkitTransform = 'translateZ(0px ) \
        rotateX( ' + worldXAngle * (-1) + 'deg) \
        rotateY( ' + worldYAngle * (-1) + 'deg)';
    } );
    
    var mask = $("#chromeNote-cmdMenu-mask");
    mask.animSub({
        open:[
            {
                elem: mask,
                beforeAnimate: function () {
                    mask.removeClass("chromeNote-hide");
                    mask.removeClass("chromeNote-transform-scale-point1");
                    
                    mask.removeClass("animateScaleDown");
                    mask.removeClass("scaleDown");
                },
                animateClass: "animateScaleUp", 
                endStatusClass: "scaleUp"
            }
        ],
        close: [
            {
                elem: mask,
                beforeAnimate: function () {
                    mask.removeClass("animateScaleUp");
                    mask.removeClass("scaleUp");
                },
                animateClass: "animateScaleDown",
                endStatusClass: "scaleDown",
                afterAnimate: function () {
                    mask.addClass("chromeNote-hide");
                    mask.addClass("chromeNote-transform-scale-point1");
                }
            }
        ]
    });

    mask.animPub("open");

    window.addEventListener("dblclick", function () {
        mask.animPub("open");
    })

    window.addEventListener("click", function () {
        mask.animPub("close");
    })
</script>
</html>